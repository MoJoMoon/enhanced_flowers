<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Flower Love Experience</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 20px;
            max-width: 400px;
            backdrop-filter: blur(15px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        #ui h2 {
            margin-top: 0;
            font-size: 28px;
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255,107,107,0.5);
        }
        
        #nameInput {
            width: 100%;
            padding: 15px;
            margin: 15px 0;
            border: 2px solid transparent;
            border-radius: 12px;
            font-size: 18px;
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            color: white;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }
        
        #nameInput:focus {
            outline: none;
            border: 2px solid #4ecdc4;
            background: rgba(255,255,255,0.2);
            box-shadow: 0 0 20px rgba(78,205,196,0.3);
        }
        
        #nameInput::placeholder {
            color: rgba(255,255,255,0.6);
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            margin: 8px 0;
            transition: all 0.3s ease;
            font-weight: 600;
            position: relative;
            overflow: hidden;
            width: 100%;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        
        button:active {
            transform: translateY(-1px);
        }
        
        #createButton {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            font-size: 18px;
            padding: 18px;
        }
        
        #audioButton {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        #vrButton {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            font-size: 18px;
            padding: 18px;
            margin-top: 20px;
        }
        
        #vrStatus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            display: none;
            text-align: center;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 400px;
        }
        
        #loadingIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            display: block;
            text-align: center;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 25px;
            border-radius: 20px;
            max-width: 500px;
            backdrop-filter: blur(15px);
            font-size: 14px;
            line-height: 1.8;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .section-title {
            color: #4ecdc4;
            font-weight: bold;
            margin-top: 15px;
            margin-bottom: 8px;
        }
        
        .feature-highlight {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .loading-spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 4px solid #4ecdc4;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="ui">
        <h2>üíñ‚ú® VR Love Garden</h2>
        <input type="text" id="nameInput" placeholder="Enter a word or name..." value="LOVE">
        
        <button id="createButton" onclick="createFlowerDisplay()">üå∏ Create Magical Garden</button>
        <button id="audioButton" onclick="toggleAudio()">üîä Enable Ambient Sounds</button>
        <button id="vrButton" onclick="enterVR()">ü•Ω Enter VR Experience</button>
    </div>
    
    <div id="loadingIndicator">
        <h3>üå∏ Loading Magical Garden...</h3>
        <div class="loading-spinner"></div>
        <p>Preparing your immersive flower experience...</p>
    </div>
    
    <div id="vrStatus">
        <h3>VR Status</h3>
        <p id="vrMessage">Checking VR support...</p>
    </div>
    
    <div id="instructions">
        <div class="section-title">üñ•Ô∏è Desktop Controls:</div>
        ‚Ä¢ Enter a word and create beautiful rainbow flower arrangements<br>
        ‚Ä¢ Use WASD to move, mouse to look around<br>
        ‚Ä¢ Click to lock mouse for smooth camera control<br><br>
        
        <div class="section-title">ü•Ω Meta Quest VR Controls:</div>
        ‚Ä¢ <span class="feature-highlight">Right Thumbstick</span>: Move forward/back/left/right<br>
        ‚Ä¢ <span class="feature-highlight">Left Thumbstick</span>: Turn and look around<br>
        ‚Ä¢ <span class="feature-highlight">Trigger Buttons</span>: Touch flowers to make them bloom<br>
        ‚Ä¢ <span class="feature-highlight">Grip Buttons</span>: Pick up and move flowers<br>
        ‚Ä¢ Natural head movement for immersive looking around<br><br>
        
        <div class="section-title">‚ú® Special Features:</div>
        ‚Ä¢ <span class="feature-highlight">Rainbow Magic</span>: Flowers shift through beautiful colors<br>
        ‚Ä¢ <span class="feature-highlight">Interactive Blooms</span>: Touch flowers to see them react<br>
        ‚Ä¢ <span class="feature-highlight">Ambient Sounds</span>: Birds, wind, and magical chimes<br>
        ‚Ä¢ <span class="feature-highlight">3D Text</span>: Your word spelled out in living flowers
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, flowers = [], interactiveFlowers = [];
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let vrMovement = { x: 0, z: 0 };
        let dolly, cameraRig;
        let audioContext, audioEnabled = false;
        let windSound, birdSounds = [], harpSynth, magicSynth;
        let selectedFlower = null;
        let raycaster = new THREE.Raycaster();
        let tempMatrix = new THREE.Matrix4();
        let isInitialized = false;
        let particleSystem, magicParticles;
        
        // Loading management
        function hideLoadingIndicator() {
            const loadingEl = document.getElementById('loadingIndicator');
            if (loadingEl) {
                loadingEl.style.display = 'none';
            }
        }
        
        function showLoadingIndicator(message = 'Loading...') {
            const loadingEl = document.getElementById('loadingIndicator');
            if (loadingEl) {
                loadingEl.innerHTML = '<h3>üå∏ ' + message + '</h3><div class="loading-spinner"></div><p>Preparing your magical garden...</p>';
                loadingEl.style.display = 'block';
            }
        }
        
        // Initialize everything
        async function init() {
            try {
                console.log('Starting initialization...');
                showLoadingIndicator('Initializing VR Love Garden');
                
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.Fog(0x87CEEB, 5, 30);
                
                // Create camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 1.6, 8);
                
                // Enhanced renderer
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.xr.enabled = true;
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2;
                
                document.body.appendChild(renderer.domElement);
                
                // Setup lighting
                setupLighting();
                
                // Create ground
                createGround();
                
                // Setup VR controllers
                setupVRControllers();
                
                // Setup desktop controls
                setupControls();
                
                // Create particles
                createParticles();
                
                // Start animation loop
                renderer.setAnimationLoop(animate);
                
                // Create initial display
                createFlowerDisplay();
                
                // Check VR support
                await checkVRSupport();
                
                isInitialized = true;
                hideLoadingIndicator();
                
                console.log('Initialization complete!');
                
            } catch (error) {
                console.error('Initialization error:', error);
                const loadingEl = document.getElementById('loadingIndicator');
                if (loadingEl) {
                    loadingEl.innerHTML = '<h3>‚ùå Loading Error</h3><p>Please refresh and try again. Error: ' + error.message + '</p>';
                }
            }
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(15, 25, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Colored accent lights
            const lights = [
                { color: 0xff69b4, position: [8, 4, 8], intensity: 0.8 },
                { color: 0x4169e1, position: [-8, 4, -8], intensity: 0.8 },
                { color: 0x32cd32, position: [8, 4, -8], intensity: 0.6 },
                { color: 0xffd700, position: [-8, 4, 8], intensity: 0.6 }
            ];
            
            lights.forEach(lightConfig => {
                const light = new THREE.PointLight(lightConfig.color, lightConfig.intensity, 15);
                light.position.set(...lightConfig.position);
                scene.add(light);
            });
        }
        
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3a5f3a });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add grass patches
            for (let i = 0; i < 50; i++) {
                const grassPatch = new THREE.Mesh(
                    new THREE.PlaneGeometry(2, 2),
                    new THREE.MeshLambertMaterial({ color: 0x4a7c4a })
                );
                grassPatch.rotation.x = -Math.PI / 2;
                grassPatch.position.set(
                    (Math.random() - 0.5) * 60,
                    0.01,
                    (Math.random() - 0.5) * 60
                );
                scene.add(grassPatch);
            }
        }
        
        function createParticles() {
            // Floating particles
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 60;
                positions[i3 + 1] = Math.random() * 10;
                positions[i3 + 2] = (Math.random() - 0.5) * 60;
                
                const hue = Math.random();
                const color = new THREE.Color().setHSL(hue, 0.7, 0.6);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }
        
        async function checkVRSupport() {
            const vrMessage = document.getElementById('vrMessage');
            const vrStatus = document.getElementById('vrStatus');
            
            if (!navigator.xr) {
                vrMessage.innerHTML = '‚ùå WebXR not supported.<br>Please use the <strong>Meta Quest Browser</strong> for VR experience.';
                vrStatus.style.display = 'block';
                setTimeout(() => vrStatus.style.display = 'none', 5000);
                return;
            }
            
            try {
                const supported = await navigator.xr.isSessionSupported('immersive-vr');
                if (supported) {
                    vrMessage.innerHTML = '‚úÖ <strong>VR Ready!</strong><br>Put on your Quest and click "Enter VR Experience"';
                    document.getElementById('vrButton').style.background = 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)';
                } else {
                    vrMessage.innerHTML = 'VR device not detected.<br>Desktop mode available with full features.';
                }
                vrStatus.style.display = 'block';
                setTimeout(() => vrStatus.style.display = 'none', 4000);
            } catch (error) {
                console.error('VR check error:', error);
                vrMessage.innerHTML = 'VR check failed.<br>Desktop mode available.';
                vrStatus.style.display = 'block';
                setTimeout(() => vrStatus.style.display = 'none', 4000);
            }
        }
        
        function setupVRControllers() {
            // Camera rig for VR
            cameraRig = new THREE.Group();
            cameraRig.position.set(0, 0, 8);
            scene.add(cameraRig);
            
            dolly = new THREE.Group();
            cameraRig.add(dolly);
            dolly.add(camera);
            
            // Controllers
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            controller1.addEventListener('squeeze', onSqueeze);
            controller1.addEventListener('squeezeend', onSqueezeEnd);
            controller1.addEventListener('connected', function(event) {
                this.add(buildController(event.data));
            });
            dolly.add(controller1);
            
            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('squeeze', onSqueeze);
            controller2.addEventListener('squeezeend', onSqueezeEnd);
            controller2.addEventListener('connected', function(event) {
                this.add(buildController(event.data));
            });
            dolly.add(controller2);
            
            // Controller grips
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(buildControllerModel());
            dolly.add(controllerGrip1);
            
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(buildControllerModel());
            dolly.add(controllerGrip2);
        }
        
        function buildController(data) {
            let geometry, material;
            
            switch (data.targetRayMode) {
                case 'tracked-pointer':
                    geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 1, 0.8, 0, 0.5, 0.5], 3));
                    material = new THREE.LineBasicMaterial({ 
                        vertexColors: true, 
                        blending: THREE.AdditiveBlending
                    });
                    return new THREE.Line(geometry, material);
                case 'gaze':
                    geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, -1);
                    material = new THREE.MeshBasicMaterial({ 
                        color: 0x4ecdc4,
                        opacity: 0.7, 
                        transparent: true 
                    });
                    return new THREE.Mesh(geometry, material);
            }
        }
        
        function buildControllerModel() {
            const group = new THREE.Group();
            
            const geometry = new THREE.BoxGeometry(0.06, 0.14, 0.09);
            const material = new THREE.MeshPhongMaterial({ color: 0x202020 });
            const controller = new THREE.Mesh(geometry, material);
            group.add(controller);
            
            const tipGeometry = new THREE.SphereGeometry(0.04);
            const tipMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4ecdc4,
                emissive: 0x4ecdc4,
                emissiveIntensity: 0.8
            });
            const tip = new THREE.Mesh(tipGeometry, tipMaterial);
            tip.position.set(0, 0.07, 0);
            group.add(tip);
            
            return group;
        }
        
        function onSelectStart(event) {
            const controller = event.target;
            
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            const intersects = raycaster.intersectObjects(interactiveFlowers, true);
            if (intersects.length > 0) {
                const flower = intersects[0].object.parent;
                animateFlowerInteraction(flower);
                createMagicBurst(intersects[0].point);
            }
        }
        
        function onSelectEnd(event) {
            // Reset visual feedback
        }
        
        function onSqueeze(event) {
            const controller = event.target;
            
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            const intersects = raycaster.intersectObjects(interactiveFlowers, true);
            if (intersects.length > 0) {
                selectedFlower = intersects[0].object.parent;
                selectedFlower.userData.originalParent = selectedFlower.parent;
                controller.attach(selectedFlower);
                selectedFlower.scale.multiplyScalar(1.2);
                
                if (audioEnabled && magicSynth) {
                    magicSynth.triggerAttackRelease('C6', '8n');
                }
            }
        }
        
        function onSqueezeEnd(event) {
            if (selectedFlower) {
                const originalParent = selectedFlower.userData.originalParent || scene;
                originalParent.attach(selectedFlower);
                selectedFlower.scale.divideScalar(1.2);
                selectedFlower = null;
            }
        }
        
        function animateFlowerInteraction(flower) {
            const duration = 2000;
            const startScale = flower.scale.x;
            const startTime = Date.now();
            
            function updateAnimation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                let easeProgress;
                if (progress < 0.3) {
                    easeProgress = progress / 0.3;
                    easeProgress = 1 - Math.pow(1 - easeProgress, 3);
                } else {
                    easeProgress = 1 + 0.3 * Math.pow(1 - (progress - 0.3) / 0.7, 2);
                }
                
                const scale = startScale * easeProgress;
                flower.scale.set(scale, scale, scale);
                flower.rotation.y += 0.03 * Math.sin(progress * Math.PI * 2);
                
                if (progress < 1) {
                    requestAnimationFrame(updateAnimation);
                } else {
                    flower.scale.set(startScale, startScale, startScale);
                }
            }
            
            updateAnimation();
            
            if (audioEnabled && harpSynth) {
                const notes = ['C5', 'E5', 'G5', 'C6'];
                notes.forEach((note, index) => {
                    setTimeout(() => {
                        harpSynth.triggerAttackRelease(note, '8n');
                    }, index * 100);
                });
            }
        }
        
        function createMagicBurst(position) {
            const burstGeometry = new THREE.BufferGeometry();
            const burstCount = 15;
            const burstPositions = new Float32Array(burstCount * 3);
            const burstVelocities = [];
            
            for (let i = 0; i < burstCount; i++) {
                const i3 = i * 3;
                burstPositions[i3] = position.x;
                burstPositions[i3 + 1] = position.y;
                burstPositions[i3 + 2] = position.z;
                
                burstVelocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.1,
                    (Math.random() - 0.5) * 0.1
                ));
            }
            
            burstGeometry.setAttribute('position', new THREE.BufferAttribute(burstPositions, 3));
            
            const burstMaterial = new THREE.PointsMaterial({
                size: 0.1,
                color: 0xffd700,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            
            const burst = new THREE.Points(burstGeometry, burstMaterial);
            scene.add(burst);
            
            let burstTime = 0;
            function animateBurst() {
                burstTime += 0.016;
                const positions = burst.geometry.attributes.position.array;
                
                for (let i = 0; i < burstCount; i++) {
                    const i3 = i * 3;
                    const velocity = burstVelocities[i];
                    
                    positions[i3] += velocity.x;
                    positions[i3 + 1] += velocity.y;
                    positions[i3 + 2] += velocity.z;
                    
                    velocity.y -= 0.002;
                }
                
                burst.geometry.attributes.position.needsUpdate = true;
                burst.material.opacity = Math.max(0, 1 - burstTime * 2);
                
                if (burstTime < 0.5) {
                    requestAnimationFrame(animateBurst);
                } else {
                    scene.remove(burst);
                }
            }
            animateBurst();
        }
        
        function handleVRMovement() {
            if (!renderer.xr.isPresenting) return;
            
            const session = renderer.xr.getSession();
            if (!session || !session.inputSources) return;
            
            vrMovement.x = 0;
            vrMovement.z = 0;
            
            for (let i = 0; i < session.inputSources.length; i++) {
                const inputSource = session.inputSources[i];
                const gamepad = inputSource.gamepad;
                
                if (!gamepad || gamepad.axes.length < 4) continue;
                
                if (inputSource.handedness === 'right') {
                    const thumbstickX = gamepad.axes[2];
                    const thumbstickY = gamepad.axes[3];
                    
                    if (Math.abs(thumbstickX) > 0.15) vrMovement.x = -thumbstickX * 0.08;
                    if (Math.abs(thumbstickY) > 0.15) vrMovement.z = thumbstickY * 0.08;
                }
                
                if (inputSource.handedness === 'left') {
                    const rotateX = gamepad.axes[2];
                    
                    if (Math.abs(rotateX) > 0.15) {
                        cameraRig.rotation.y += rotateX * 0.03;
                    }
                }
            }
            
            if (Math.abs(vrMovement.x) > 0.01 || Math.abs(vrMovement.z) > 0.01) {
                const moveVector = new THREE.Vector3(vrMovement.x, 0, vrMovement.z);
                moveVector.applyQuaternion(cameraRig.quaternion);
                cameraRig.position.add(moveVector);
            }
        }
        
        async function toggleAudio() {
            const audioButton = document.getElementById('audioButton');
            
            if (!audioEnabled) {
                try {
                    await Tone.start();
                    audioEnabled = true;
                    audioButton.textContent = 'üîá Disable Ambient Sounds';
                    
                    createWindSound();
                    createBirdSounds();
                    createHarpSounds();
                    createMagicalSounds();
                    
                } catch (error) {
                    console.error('Failed to enable audio:', error);
                }
            } else {
                Tone.Transport.stop();
                audioEnabled = false;
                audioButton.textContent = 'üîä Enable Ambient Sounds';
            }
        }
        
        function createWindSound() {
            const noise = new Tone.Noise("pink").start();
            const filter = new Tone.Filter(400, "lowpass").toDestination();
            const autoFilter = new Tone.AutoFilter(0.08).connect(filter);
            const reverb = new Tone.Reverb(4).connect(autoFilter);
            
            noise.connect(reverb);
            noise.volume.value = -35;
            
            windSound = { noise, filter, autoFilter, reverb };
        }
        
        function createBirdSounds() {
            const birdTypes = [
                { notes: ['C5', 'E5', 'G5'], pattern: "random", interval: 12 },
                { notes: ['F5', 'A5', 'C6'], pattern: "up", interval: 15 },
                { notes: ['D5', 'F#5', 'A5'], pattern: "down", interval: 18 }
            ];
            
            birdTypes.forEach((birdType, index) => {
                const synth = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.03,
                        decay: 0.08,
                        sustain: 0.1,
                        release: 0.3
                    }
                });
                
                const reverb = new Tone.Reverb(2).toDestination();
                synth.connect(reverb);
                synth.volume.value = -28;
                
                const pattern = new Tone.Pattern((time, note) => {
                    synth.triggerAttackRelease(note, "16n", time);
                }, birdType.notes, birdType.pattern);
                
                pattern.start(Math.random() * 5);
                pattern.interval = birdType.interval + Math.random() * 10;
                
                birdSounds.push({ synth, pattern, reverb });
            });
            
            Tone.Transport.start();
        }
        
        function createHarpSounds() {
            harpSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.1,
                    decay: 1.2,
                    sustain: 0.1,
                    release: 2.0
                }
            });
            
            const reverb = new Tone.Reverb(4).toDestination();
            const delay = new Tone.PingPongDelay("8n", 0.3).connect(reverb);
            harpSynth.connect(delay);
            harpSynth.volume.value = -22;
        }
        
        function createMagicalSounds() {
            magicSynth = new Tone.Synth({
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.05,
                    decay: 0.3,
                    sustain: 0.2,
                    release: 0.8
                }
            });
            
            const chorus = new Tone.Chorus(4, 2.5, 0.5).start();
            const reverb = new Tone.Reverb(3).toDestination();
            magicSynth.connect(chorus);
            chorus.connect(reverb);
            magicSynth.volume.value = -25;
        }
        
        function createFlower(x, y, z, scale = 1, rainbowMode = false) {
            const flowerGroup = new THREE.Group();
            
            // Petals with rainbow colors
            const colors = rainbowMode ? 
                [0xff0000, 0xff8000, 0xffff00, 0x80ff00, 0x00ff00, 0x00ff80, 0x00ffff, 0x0080ff, 0x0000ff, 0x8000ff, 0xff00ff, 0xff0080] :
                [0xff69b4, 0xff1493, 0xffc0cb, 0xffb6c1];
            
            const petalCount = 12;
            for (let i = 0; i < petalCount; i++) {
                const angle = (i / petalCount) * Math.PI * 2;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                const petal = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3 * scale, 8, 6).scale(1, 0.3, 0.6),
                    new THREE.MeshPhongMaterial({ 
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.2,
                        shininess: 40
                    })
                );
                
                petal.position.set(
                    Math.cos(angle) * 0.5 * scale,
                    0,
                    Math.sin(angle) * 0.5 * scale
                );
                petal.rotation.z = angle;
                petal.castShadow = true;
                flowerGroup.add(petal);
            }
            
            // Center
            const center = new THREE.Mesh(
                new THREE.SphereGeometry(0.2 * scale),
                new THREE.MeshPhongMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.3
                })
            );
            flowerGroup.add(center);
            
            // Stem
            const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05 * scale, 0.05 * scale, 1.5 * scale),
                new THREE.MeshLambertMaterial({ color: 0x228b22 })
            );
            stem.position.y = -0.75 * scale;
            stem.castShadow = true;
            flowerGroup.add(stem);
            
            // Leaves
            for (let i = 0; i < 2; i++) {
                const leaf = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2 * scale, 8, 6).scale(2, 0.1, 0.8),
                    new THREE.MeshLambertMaterial({ color: 0x32cd32 })
                );
                leaf.position.set(
                    (i === 0 ? 0.3 : -0.3) * scale,
                    -0.5 * scale,
                    0
                );
                leaf.rotation.z = (i === 0 ? -0.5 : 0.5);
                leaf.castShadow = true;
                flowerGroup.add(leaf);
            }
            
            flowerGroup.position.set(x, y, z);
            flowerGroup.userData.originalY = y;
            flowerGroup.userData.swayOffset = Math.random() * Math.PI * 2;
            flowerGroup.userData.rainbowMode = rainbowMode;
            
            interactiveFlowers.push(flowerGroup);
            return flowerGroup;
        }
        
        function createFlowerDisplay() {
            clearExistingFlowers();
            
            const name = document.getElementById('nameInput').value.toUpperCase() || 'LOVE';
            const letterSpacing = 4;
            const startX = -(name.length * letterSpacing) / 2;
            
            // Create name in flowers with rainbow colors
            for (let i = 0; i < name.length; i++) {
                const letter = name[i];
                if (letter === ' ') continue;
                
                const letterFlowers = create3DLetterFlowers(letter, startX + i * letterSpacing, 2, 0);
                letterFlowers.forEach(flower => {
                    flowers.push(flower);
                    scene.add(flower);
                });
            }
            
            // Add surrounding rainbow flowers
            const radius = 8;
            const surroundingFlowers = 24;
            
            for (let i = 0; i < surroundingFlowers; i++) {
                const angle = (i / surroundingFlowers) * Math.PI * 2;
                const distance = radius + Math.sin(i * 0.5) * 2;
                
                const flower = createFlower(
                    Math.cos(angle) * distance,
                    Math.random() * 2 + 1,
                    Math.sin(angle) * distance,
                    1 + Math.random() * 0.5,
                    true // Rainbow mode
                );
                
                flowers.push(flower);
                scene.add(flower);
            }
            
            // Add floating petals
            createFloatingPetals();
        }
        
        function create3DLetterFlowers(letter, offsetX, offsetY, offsetZ) {
            const flowerPositions = getLetterPositions(letter);
            const letterFlowers = [];
            
            flowerPositions.forEach((pos) => {
                const flower = createFlower(
                    pos.x + offsetX,
                    pos.y + offsetY,
                    pos.z + offsetZ,
                    1.2,
                    true // Rainbow mode for letter flowers
                );
                letterFlowers.push(flower);
            });
            
            return letterFlowers;
        }
        
        function createFloatingPetals() {
            const petalCount = 30;
            
            for (let i = 0; i < petalCount; i++) {
                const petalGeometry = new THREE.SphereGeometry(0.1, 6, 4);
                petalGeometry.scale(1, 0.3, 0.6);
                
                const colors = [0xff69b4, 0xff1493, 0xffc0cb, 0xffd700, 0x4ecdc4];
                const petal = new THREE.Mesh(
                    petalGeometry,
                    new THREE.MeshPhongMaterial({
                        color: colors[Math.floor(Math.random() * colors.length)],
                        transparent: true,
                        opacity: 0.8
                    })
                );
                
                petal.position.set(
                    (Math.random() - 0.5) * 30,
                    Math.random() * 8 + 3,
                    (Math.random() - 0.5) * 30
                );
                
                petal.userData.floatingPetal = true;
                petal.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    -Math.random() * 0.01 - 0.005,
                    (Math.random() - 0.5) * 0.02
                );
                petal.userData.rotationSpeed = Math.random() * 0.1;
                
                scene.add(petal);
                flowers.push(petal);
            }
        }
        
        function clearExistingFlowers() {
            flowers.forEach(flower => {
                scene.remove(flower);
                const index = interactiveFlowers.indexOf(flower);
                if (index > -1) interactiveFlowers.splice(index, 1);
            });
            flowers = [];
        }
        
        function getLetterPositions(letter) {
            const patterns = {
                'L': [{x:-0.6,y:0,z:0}, {x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:-0.2,y:0,z:0}, {x:0.2,y:0,z:0}, {x:0.5,y:0,z:0}],
                'O': [{x:-0.4,y:0.3,z:0}, {x:-0.4,y:0.75,z:0}, {x:-0.4,y:1.2,z:0}, {x:0.4,y:0.3,z:0}, {x:0.4,y:0.75,z:0}, {x:0.4,y:1.2,z:0}, {x:-0.2,y:0,z:0}, {x:0.2,y:0,z:0}, {x:-0.2,y:1.5,z:0}, {x:0.2,y:1.5,z:0}],
                'V': [{x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:0.6,y:1,z:0}, {x:0.6,y:1.5,z:0}, {x:-0.4,y:0.6,z:0}, {x:0.4,y:0.6,z:0}, {x:-0.2,y:0.3,z:0}, {x:0.2,y:0.3,z:0}, {x:0,y:0,z:0}],
                'E': [{x:-0.6,y:0,z:0}, {x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:-0.2,y:0,z:0}, {x:-0.2,y:0.75,z:0}, {x:-0.2,y:1.5,z:0}, {x:0.2,y:0,z:0}, {x:0.2,y:0.75,z:0}, {x:0.2,y:1.5,z:0}, {x:0.5,y:0,z:0}, {x:0.5,y:1.5,z:0}],
                'A': [{x:-0.6,y:0,z:0}, {x:0.6,y:0,z:0}, {x:-0.4,y:0.5,z:0}, {x:0.4,y:0.5,z:0}, {x:-0.2,y:1,z:0}, {x:0.2,y:1,z:0}, {x:0,y:1.5,z:0}, {x:-0.3,y:0.7,z:0}, {x:0.3,y:0.7,z:0}],
                'B': [{x:-0.6,y:0,z:0}, {x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:-0.2,y:0,z:0}, {x:-0.2,y:0.75,z:0}, {x:-0.2,y:1.5,z:0}, {x:0.2,y:0.1,z:0}, {x:0.2,y:1.4,z:0}, {x:0.4,y:0.4,z:0}, {x:0.4,y:1.1,z:0}],
                'C': [{x:-0.4,y:0.3,z:0}, {x:-0.4,y:0.6,z:0}, {x:-0.4,y:0.9,z:0}, {x:-0.4,y:1.2,z:0}, {x:-0.1,y:0,z:0}, {x:-0.1,y:1.5,z:0}, {x:0.2,y:0.1,z:0}, {x:0.2,y:1.4,z:0}],
                'D': [{x:-0.6,y:0,z:0}, {x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:-0.2,y:0,z:0}, {x:-0.2,y:1.5,z:0}, {x:0.2,y:0.2,z:0}, {x:0.2,y:1.3,z:0}, {x:0.5,y:0.75,z:0}],
                'F': [{x:-0.6,y:0,z:0}, {x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:-0.2,y:0.75,z:0}, {x:-0.2,y:1.5,z:0}, {x:0.2,y:0.75,z:0}, {x:0.2,y:1.5,z:0}],
                'G': [{x:-0.4,y:0.3,z:0}, {x:-0.4,y:0.6,z:0}, {x:-0.4,y:0.9,z:0}, {x:-0.4,y:1.2,z:0}, {x:-0.1,y:0,z:0}, {x:-0.1,y:1.5,z:0}, {x:0.2,y:0.1,z:0}, {x:0.5,y:0.75,z:0}, {x:0.2,y:0.75,z:0}],
                'H': [{x:-0.6,y:0,z:0}, {x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:0.6,y:0,z:0}, {x:0.6,y:0.5,z:0}, {x:0.6,y:1,z:0}, {x:0.6,y:1.5,z:0}, {x:0,y:0.75,z:0}],
                'I': [{x:0,y:0,z:0}, {x:0,y:0.5,z:0}, {x:0,y:1,z:0}, {x:0,y:1.5,z:0}, {x:-0.4,y:0,z:0}, {x:0.4,y:0,z:0}, {x:-0.4,y:1.5,z:0}, {x:0.4,y:1.5,z:0}],
                'J': [{x:0.6,y:0.5,z:0}, {x:0.6,y:1,z:0}, {x:0.6,y:1.5,z:0}, {x:0.2,y:0,z:0}, {x:-0.2,y:0.1,z:0}, {x:-0.5,y:0.3,z:0}],
                'K': [{x:-0.6,y:0,z:0}, {x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:-0.1,y:0.75,z:0}, {x:0.2,y:0.4,z:0}, {x:0.2,y:1.1,z:0}, {x:0.5,y:0,z:0}, {x:0.5,y:1.5,z:0}],
                'M': [{x:-0.7,y:0,z:0}, {x:-0.7,y:0.5,z:0}, {x:-0.7,y:1,z:0}, {x:-0.7,y:1.5,z:0}, {x:0.7,y:0,z:0}, {x:0.7,y:0.5,z:0}, {x:0.7,y:1,z:0}, {x:0.7,y:1.5,z:0}, {x:0,y:0.9,z:0}],
                'N': [{x:-0.6,y:0,z:0}, {x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:0.6,y:0,z:0}, {x:0.6,y:0.5,z:0}, {x:0.6,y:1,z:0}, {x:0.6,y:1.5,z:0}, {x:0,y:0.75,z:0}],
                'P': [{x:-0.6,y:0,z:0}, {x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:-0.2,y:0.75,z:0}, {x:-0.2,y:1.5,z:0}, {x:0.2,y:1.4,z:0}, {x:0.2,y:0.9,z:0}],
                'Q': [{x:-0.4,y:0.3,z:0}, {x:-0.4,y:0.75,z:0}, {x:-0.4,y:1.2,z:0}, {x:0.4,y:0.3,z:0}, {x:0.4,y:0.75,z:0}, {x:0.4,y:1.2,z:0}, {x:-0.2,y:0,z:0}, {x:0.2,y:0,z:0}, {x:-0.2,y:1.5,z:0}, {x:0.2,y:1.5,z:0}, {x:0.6,y:0.1,z:0}],
                'R': [{x:-0.6,y:0,z:0}, {x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:-0.2,y:0.75,z:0}, {x:-0.2,y:1.5,z:0}, {x:0.2,y:1.4,z:0}, {x:0.2,y:0.9,z:0}, {x:0.4,y:0.3,z:0}, {x:0.6,y:0,z:0}],
                'S': [{x:-0.4,y:1.2,z:0}, {x:-0.2,y:1.5,z:0}, {x:0.2,y:1.5,z:0}, {x:0.4,y:1.2,z:0}, {x:-0.2,y:0.75,z:0}, {x:0.2,y:0.75,z:0}, {x:-0.4,y:0.3,z:0}, {x:-0.2,y:0,z:0}, {x:0.2,y:0,z:0}, {x:0.4,y:0.3,z:0}],
                'T': [{x:-0.6,y:1.5,z:0}, {x:-0.3,y:1.5,z:0}, {x:0,y:1.5,z:0}, {x:0.3,y:1.5,z:0}, {x:0.6,y:1.5,z:0}, {x:0,y:0,z:0}, {x:0,y:0.5,z:0}, {x:0,y:1,z:0}],
                'U': [{x:-0.6,y:0.5,z:0}, {x:-0.6,y:1,z:0}, {x:-0.6,y:1.5,z:0}, {x:0.6,y:0.5,z:0}, {x:0.6,y:1,z:0}, {x:0.6,y:1.5,z:0}, {x:-0.2,y:0,z:0}, {x:0,y:0,z:0}, {x:0.2,y:0,z:0}],
                'W': [{x:-0.7,y:0.5,z:0}, {x:-0.7,y:1,z:0}, {x:-0.7,y:1.5,z:0}, {x:0.7,y:0.5,z:0}, {x:0.7,y:1,z:0}, {x:0.7,y:1.5,z:0}, {x:0,y:0.4,z:0}, {x:-0.35,y:0.2,z:0}, {x:0.35,y:0.2,z:0}],
                'X': [{x:-0.6,y:0,z:0}, {x:-0.3,y:0.4,z:0}, {x:0,y:0.75,z:0}, {x:0.3,y:0.4,z:0}, {x:0.6,y:0,z:0}, {x:0.6,y:1.5,z:0}, {x:0.3,y:1.1,z:0}, {x:-0.3,y:1.1,z:0}, {x:-0.6,y:1.5,z:0}],
                'Y': [{x:-0.6,y:1.2,z:0}, {x:-0.3,y:0.9,z:0}, {x:0,y:0.75,z:0}, {x:0.3,y:0.9,z:0}, {x:0.6,y:1.2,z:0}, {x:0,y:0,z:0}, {x:0,y:0.3,z:0}, {x:0,y:0.5,z:0}],
                'Z': [{x:-0.6,y:1.5,z:0}, {x:-0.2,y:1.5,z:0}, {x:0.2,y:1.5,z:0}, {x:0.6,y:1.5,z:0}, {x:0,y:0.75,z:0}, {x:-0.6,y:0,z:0}, {x:-0.2,y:0,z:0}, {x:0.2,y:0,z:0}, {x:0.6,y:0,z:0}]
            };
            
            return patterns[letter] || [{x:0,y:0.75,z:0}];
        }
        
        function setupControls() {
            const onKeyDown = function(event) {
                switch(event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = true;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = true;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = true;
                        break;
                }
            };
            
            const onKeyUp = function(event) {
                switch(event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = false;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = false;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = false;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = false;
                        break;
                }
            };
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mouse controls
            let mouseX = 0, mouseY = 0;
            document.addEventListener('mousemove', (event) => {
                if (document.pointerLockElement === renderer.domElement) {
                    mouseX += event.movementX * 0.002;
                    mouseY += event.movementY * 0.002;
                    mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                    
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = -mouseX;
                    camera.rotation.x = -mouseY;
                }
            });
            
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
        }
        
        function animate() {
            handleVRMovement();
            
            // Desktop movement
            if (!renderer.xr.isPresenting) {
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.z = Number(moveBackward) - Number(moveForward);
                direction.normalize();
                
                if (moveForward || moveBackward) velocity.z -= direction.z * 0.12;
                if (moveLeft || moveRight) velocity.x -= direction.x * 0.12;
                
                velocity.multiplyScalar(0.85);
                
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                const right = new THREE.Vector3();
                right.crossVectors(forward, camera.up).normalize();
                
                camera.position.addScaledVector(right, -velocity.x);
                camera.position.addScaledVector(forward, -velocity.z);
            }
            
            const time = Date.now() * 0.001;
            
            // Animate flowers
            flowers.forEach((flower, index) => {
                if (flower.userData.originalY !== undefined) {
                    flower.position.y = flower.userData.originalY + Math.sin(time + flower.userData.swayOffset) * 0.08;
                    flower.rotation.z = Math.sin(time + flower.userData.swayOffset + 1) * 0.03;
                    flower.rotation.y += 0.001;
                }
                
                // Rainbow color shifting
                if (flower.userData.rainbowMode && flower.children) {
                    const hue = (time * 0.3 + index * 0.1) % 1;
                    const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
                    flower.children.forEach(child => {
                        if (child.material && child.material.color) {
                            child.material.color.copy(color);
                            if (child.material.emissive) {
                                child.material.emissive.copy(color);
                                child.material.emissiveIntensity = 0.2;
                            }
                        }
                    });
                }
                
                // Floating petals
                if (flower.userData.floatingPetal) {
                    flower.position.add(flower.userData.velocity);
                    flower.rotation.x += flower.userData.rotationSpeed;
                    flower.rotation.y += flower.userData.rotationSpeed * 0.7;
                    flower.rotation.z += flower.userData.rotationSpeed * 0.3;
                    
                    if (flower.position.y < -2) {
                        flower.position.y = 12;
                        flower.position.x = (Math.random() - 0.5) * 40;
                        flower.position.z = (Math.random() - 0.5) * 40;
                    }
                }
            });
            
            // Animate particles
            if (particleSystem) {
                const positions = particleSystem.geometry.attributes.position.array;
                const colors = particleSystem.geometry.attributes.color.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += Math.sin(time * 0.5 + i * 0.01) * 0.02;
                    positions[i] += Math.sin(time * 0.3 + i * 0.005) * 0.01;
                    positions[i + 2] += Math.cos(time * 0.3 + i * 0.005) * 0.01;
                    
                    const colorIndex = i / 3;
                    const hue = (time * 0.1 + colorIndex * 0.01) % 1;
                    const color = new THREE.Color().setHSL(hue, 0.7, 0.6);
                    colors[i] = color.r;
                    colors[i + 1] = color.g;
                    colors[i + 2] = color.b;
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.geometry.attributes.color.needsUpdate = true;
                particleSystem.rotation.y += 0.001;
            }
            
            renderer.render(scene, camera);
        }
        
        async function enterVR() {
            const vrMessage = document.getElementById('vrMessage');
            const vrStatus = document.getElementById('vrStatus');
            
            console.log('Attempting to enter VR...');
            
            if (!isInitialized) {
                console.log('System not fully initialized yet');
                vrMessage.innerHTML = '‚è≥ <strong>Please wait...</strong><br>The experience is still loading.<br>Try again in a moment.';
                vrStatus.style.display = 'block';
                setTimeout(() => vrStatus.style.display = 'none', 3000);
                return;
            }
            
            if (!navigator.xr) {
                console.log('WebXR not supported');
                vrMessage.innerHTML = '‚ùå WebXR not supported.<br><strong>Please use the Meta Quest Browser</strong><br>1. Open Quest Browser on your headset<br>2. Navigate to this page<br>3. Click "Enter VR Experience"';
                vrStatus.style.display = 'block';
                setTimeout(() => vrStatus.style.display = 'none', 8000);
                return;
            }
            
            try {
                console.log('Checking VR session support...');
                const supported = await navigator.xr.isSessionSupported('immersive-vr');
                
                if (!supported) {
                    console.log('VR session not supported');
                    vrMessage.innerHTML = '‚ùå <strong>VR not available</strong><br>Please make sure:<br>‚Ä¢ You\'re using Meta Quest Browser<br>‚Ä¢ WebXR is enabled<br>‚Ä¢ Headset is properly connected';
                    vrStatus.style.display = 'block';
                    setTimeout(() => vrStatus.style.display = 'none', 8000);
                    return;
                }
                
                console.log('VR session supported, requesting session...');
                vrMessage.innerHTML = 'ü•Ω <strong>Starting VR session...</strong><br>Put on your headset and get ready for magic!';
                vrStatus.style.display = 'block';
                
                const sessionInit = {
                    requiredFeatures: ['local-floor']
                };
                
                console.log('Requesting VR session with features:', sessionInit);
                const session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                console.log('VR session obtained successfully');
                
                session.addEventListener('end', () => {
                    console.log('VR session ended');
                    vrMessage.innerHTML = '‚ú® <strong>VR session ended!</strong><br>Thanks for visiting the magical garden!<br>You can restart anytime.';
                    vrStatus.style.display = 'block';
                    setTimeout(() => vrStatus.style.display = 'none', 5000);
                });
                
                console.log('Setting renderer XR session...');
                await renderer.xr.setSession(session);
                console.log('VR session started successfully!');
                
                vrMessage.innerHTML = 'üå∏ <strong>Welcome to your magical garden!</strong><br>‚Ä¢ Use thumbsticks to move around<br>‚Ä¢ Point and trigger to interact with flowers<br>‚Ä¢ Grip to pick up and move flowers<br>‚Ä¢ Enjoy the rainbow colors!';
                setTimeout(() => vrStatus.style.display = 'none', 4000);
                
                // Auto-enable audio in VR if not already enabled
                if (!audioEnabled) {
                    try {
                        console.log('Auto-enabling audio for VR...');
                        await toggleAudio();
                    } catch (e) {
                        console.log('Audio auto-enable failed:', e);
                    }
                }
                
            } catch (error) {
                console.error('VR session error:', error);
                vrMessage.innerHTML = '‚ùå <strong>VR failed to start</strong><br>Error: ' + error.message + '<br><br>Try:<br>‚Ä¢ Refreshing the page<br>‚Ä¢ Using Meta Quest Browser<br>‚Ä¢ Checking headset connection';
                vrStatus.style.display = 'block';
                setTimeout(() => vrStatus.style.display = 'none', 10000);
            }
        }
        
        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start the application
        init();
    </script>
</body>
</html>
